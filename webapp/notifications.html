<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bulk Notifications Editor</title>
    <style>
        /* CSS Reset and Base Styles */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            color: #1f2328;
            background-color: #f6f8fa;
            margin: 0;
            padding: 0;
        }

        /* GitHub-inspired color variables */
        :root {
            --color-fg-default: #1f2328;
            --color-fg-muted: #656d76;
            --color-fg-subtle: #6e7781;
            --color-bg-default: #ffffff;
            --color-bg-subtle: #f6f8fa;
            --color-border-default: #d0d7de;
            --color-border-muted: #d8dee4;
            --color-accent-fg: #0969da;
            --color-success-fg: #1a7f37;
            --color-danger-fg: #d1242f;
            --color-done-fg: #8250df;
            --color-btn-bg: #f6f8fa;
            --color-btn-hover-bg: #f3f4f6;
            --color-btn-primary-bg: #1f883d;
            --color-btn-primary-hover-bg: #1a7f37;
        }

        /* Header */
        .app-header {
            background-color: #24292f;
            padding: 16px;
            color: white;
        }

        .app-header .header-inner {
            max-width: 1012px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .header-links {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .header-link {
            color: white;
            text-decoration: none;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.35);
            padding: 4px 10px;
            border-radius: 999px;
        }

        .header-link:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .app-header h1 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
        }

        /* Main container */
        .container {
            max-width: 1012px;
            margin: 0 auto;
            padding: 24px 16px;
        }

        /* Controls section */
        .controls {
            background: var(--color-bg-default);
            border: 1px solid var(--color-border-default);
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .controls-row {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .controls-row.secondary {
            margin-top: 12px;
        }

        .comment-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--color-fg-muted);
        }

        .comment-toggle input {
            width: 16px;
            height: 16px;
            accent-color: var(--color-accent-fg);
        }

        .comment-cache-status {
            font-size: 12px;
            color: var(--color-fg-muted);
        }

        .comment-cache-actions {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .rate-limit-box {
            margin-top: 12px;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--color-border-muted);
            background: var(--color-bg-subtle);
            color: var(--color-fg-muted);
            font-size: 12px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .comment-expand {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--color-fg-muted);
        }

        .comment-expand input {
            width: 16px;
            height: 16px;
            accent-color: var(--color-accent-fg);
        }

        .comment-hide {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--color-fg-muted);
        }

        .comment-hide input {
            width: 16px;
            height: 16px;
            accent-color: var(--color-accent-fg);
        }

        .comment-list {
            margin-top: 10px;
            padding-left: 0;
            list-style: none;
            display: grid;
            gap: 8px;
        }

        .comment-item {
            border: 1px solid var(--color-border-muted);
            border-radius: 6px;
            padding: 8px 10px;
            background: var(--color-bg-default);
            font-size: 12px;
            line-height: 1.4;
        }

        .comment-item .comment-meta {
            display: flex;
            justify-content: space-between;
            color: var(--color-fg-muted);
            font-size: 11px;
            margin-bottom: 6px;
        }

        /* Form elements */
        .input-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input-group label {
            font-weight: 600;
            color: var(--color-fg-default);
        }

        input[type="text"] {
            padding: 5px 12px;
            font-size: 14px;
            line-height: 20px;
            color: var(--color-fg-default);
            background-color: var(--color-bg-default);
            border: 1px solid var(--color-border-default);
            border-radius: 6px;
            outline: none;
        }

        input[type="text"]:focus {
            border-color: var(--color-accent-fg);
            box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.3);
        }

        /* Buttons */
        .btn {
            padding: 5px 16px;
            font-size: 14px;
            font-weight: 500;
            line-height: 20px;
            cursor: pointer;
            border: 1px solid var(--color-border-default);
            border-radius: 6px;
            background-color: var(--color-btn-bg);
            color: var(--color-fg-default);
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: var(--color-btn-hover-bg);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-small {
            padding: 3px 10px;
            font-size: 12px;
            line-height: 18px;
        }

        .btn-primary {
            background-color: var(--color-btn-primary-bg);
            border-color: var(--color-btn-primary-bg);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--color-btn-primary-hover-bg);
        }

        /* Status messages */
        .status-bar {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            display: none;
        }

        .status-bar.visible {
            display: block;
            margin-top: 12px;
        }

        .status-bar.info {
            background-color: #ddf4ff;
            border: 1px solid #54aeff;
            color: #0969da;
        }

        .status-bar.success {
            background-color: #dafbe1;
            border: 1px solid #4ac26b;
            color: var(--color-success-fg);
        }

        .status-bar.error {
            background-color: #ffebe9;
            border: 1px solid #ff8182;
            color: var(--color-danger-fg);
        }

        /* Notifications list */
        .notifications-container {
            background: var(--color-bg-default);
            border: 1px solid var(--color-border-default);
            border-radius: 6px;
        }

        .notifications-header {
            padding: 16px;
            border-bottom: 1px solid var(--color-border-default);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .notifications-header h2 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
        }

        .notifications-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        /* Empty state */
        .empty-state {
            padding: 48px 16px;
            text-align: center;
            color: var(--color-fg-muted);
        }

        .empty-state h3 {
            margin: 0 0 8px 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--color-fg-default);
        }

        .empty-state p {
            margin: 0;
        }

        /* Loading state */
        .loading {
            display: none;
            padding: 48px 16px;
            text-align: center;
            color: var(--color-fg-muted);
        }

        .loading.visible {
            display: block;
        }

        /* Auth status */
        .auth-status {
            font-size: 12px;
            color: var(--color-fg-muted);
        }

        .auth-status.authenticated {
            color: var(--color-success-fg);
        }

        .auth-status.error {
            color: var(--color-danger-fg);
        }

        /* Notification item styles */
        .notification-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 16px;
            border-bottom: 1px solid var(--color-border-muted);
            transition: background-color 0.1s;
        }

        .notification-item:last-child {
            border-bottom: none;
        }

        .notification-item:hover {
            background-color: var(--color-bg-subtle);
        }

        .notification-item.unread {
            background-color: #f6f8fa;
        }

        .notification-item.unread::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background-color: var(--color-accent-fg);
        }

        .notification-item {
            position: relative;
        }

        /* Type icon */
        .notification-icon {
            flex-shrink: 0;
            width: 16px;
            height: 16px;
            margin-top: 2px;
        }

        .notification-icon svg {
            width: 16px;
            height: 16px;
        }

        .notification-icon.open {
            color: var(--color-success-fg);
        }

        .notification-icon.closed {
            color: var(--color-done-fg);
        }

        .notification-icon.merged {
            color: var(--color-done-fg);
        }

        .notification-icon.draft {
            color: var(--color-fg-muted);
        }

        /* Notification content */
        .notification-content {
            flex: 1;
            min-width: 0;
        }

        .notification-title {
            font-weight: 600;
            color: var(--color-fg-default);
            text-decoration: none;
            word-break: break-word;
        }

        .notification-title:hover {
            color: var(--color-accent-fg);
            text-decoration: underline;
        }

        .notification-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
            font-size: 12px;
            color: var(--color-fg-muted);
            flex-wrap: wrap;
        }

        .comment-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 0 8px;
            font-size: 11px;
            font-weight: 500;
            line-height: 20px;
            border-radius: 2em;
            white-space: nowrap;
            border: 1px solid transparent;
        }

        .comment-tag.off {
            background-color: var(--color-bg-subtle);
            color: var(--color-fg-muted);
            border-color: var(--color-border-default);
        }

        .comment-tag.pending {
            background-color: #fff5f0;
            color: #b45309;
            border-color: #fed7aa;
        }

        .comment-tag.uninteresting {
            background-color: #dcfce7;
            color: var(--color-success-fg);
            border-color: #86efac;
        }

        .comment-tag.interesting {
            background-color: #ffebe9;
            color: var(--color-danger-fg);
            border-color: #fecaca;
        }

        .comment-tag.error {
            background-color: #fef3c7;
            color: #b45309;
            border-color: #fcd34d;
        }

        .notification-reason {
            padding: 0 6px;
            font-size: 12px;
            font-weight: 500;
            line-height: 18px;
            border-radius: 2em;
            background-color: var(--color-bg-subtle);
            border: 1px solid var(--color-border-default);
        }

        .notification-number {
            color: var(--color-fg-muted);
        }

        /* State badge */
        .state-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 0 8px;
            font-size: 12px;
            font-weight: 500;
            line-height: 22px;
            border-radius: 2em;
            white-space: nowrap;
        }

        .state-badge.open {
            background-color: #dafbe1;
            color: var(--color-success-fg);
        }

        .state-badge.closed {
            background-color: #ffebe9;
            color: var(--color-danger-fg);
        }

        .state-badge.closed.completed {
            background-color: #ddf4ff;
            color: var(--color-done-fg);
        }

        .state-badge.merged {
            background-color: #fbefff;
            color: var(--color-done-fg);
        }

        .state-badge.draft {
            background-color: var(--color-bg-subtle);
            color: var(--color-fg-muted);
        }

        .state-badge svg {
            width: 12px;
            height: 12px;
        }

        /* Actors */
        .notification-actors {
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }

        .actor-avatar {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid var(--color-bg-default);
            margin-left: -8px;
        }

        .actor-avatar:first-child {
            margin-left: 0;
        }

        /* Timestamp */
        .notification-time {
            color: var(--color-fg-muted);
            font-size: 12px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .notification-actions-inline {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .notification-done-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px 6px;
            border-radius: 6px;
            border: 1px solid transparent;
            background: transparent;
            color: var(--color-fg-muted);
            cursor: pointer;
        }

        .notification-done-btn:hover {
            background-color: var(--color-btn-hover-bg);
            border-color: var(--color-border-default);
            color: var(--color-fg-default);
        }

        .notification-done-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .notification-done-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Filter tabs */
        .filter-tabs {
            display: flex;
            gap: 0;
            border-bottom: 1px solid var(--color-border-default);
            margin: 0 -16px;
            padding: 0 16px;
        }

        .filter-tab {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            color: var(--color-fg-muted);
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            margin-bottom: -1px;
            transition: color 0.1s, border-color 0.1s;
        }

        .filter-tab:hover {
            color: var(--color-fg-default);
        }

        .filter-tab.active {
            color: var(--color-fg-default);
            border-bottom-color: #fd8c73;
        }

        .filter-tab .count {
            display: inline-block;
            min-width: 18px;
            padding: 0 6px;
            font-size: 12px;
            font-weight: 500;
            line-height: 18px;
            text-align: center;
            background-color: var(--color-bg-subtle);
            border-radius: 2em;
            margin-left: 4px;
        }

        .filter-tab.active .count {
            background-color: #fff5f3;
            color: #d1242f;
        }

        /* Selection checkboxes */
        .notification-checkbox {
            flex-shrink: 0;
            width: 16px;
            height: 16px;
            margin: 2px 0;
            cursor: pointer;
            accent-color: var(--color-accent-fg);
        }

        .notification-item.selected {
            background-color: #ddf4ff;
        }

        .notification-item.selected:hover {
            background-color: #c8e6ff;
        }

        /* Select all header */
        .select-all-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 16px;
            border-bottom: 1px solid var(--color-border-muted);
            background-color: var(--color-bg-subtle);
        }

        .select-all-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--color-accent-fg);
        }

        .select-all-label {
            font-size: 12px;
            color: var(--color-fg-muted);
            cursor: pointer;
            user-select: none;
        }

        .selection-count {
            font-size: 12px;
            color: var(--color-fg-muted);
            margin-left: auto;
        }

        .selection-count.has-selection {
            color: var(--color-accent-fg);
            font-weight: 500;
        }

        /* Mark Done button */
        .btn-danger {
            background-color: var(--color-danger-fg);
            border-color: var(--color-danger-fg);
            color: white;
        }

        .btn-danger:hover {
            background-color: #bf222c;
        }

        .btn-danger:disabled {
            background-color: #ffb3b3;
            border-color: #ffb3b3;
        }

        #mark-done-btn {
            margin-left: 8px;
        }

        /* Progress bar */
        .progress-container {
            display: none;
            margin-top: 12px;
        }

        .progress-container.visible {
            display: block;
        }

        .progress-bar-bg {
            height: 8px;
            background-color: var(--color-bg-subtle);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background-color: var(--color-btn-primary-bg);
            transition: width 0.2s ease;
            border-radius: 4px;
        }

        .progress-text {
            font-size: 12px;
            color: var(--color-fg-muted);
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <header class="app-header">
        <div class="header-inner">
            <h1>Bulk Notifications Editor</h1>
            <div class="header-links">
                <a class="header-link" href="/app/">All tools</a>
            </div>
        </div>
    </header>

    <main class="container">
        <!-- Controls Section -->
        <section class="controls">
            <div class="controls-row">
                <div class="input-group">
                    <label for="repo-input">Repository:</label>
                    <input
                        type="text"
                        id="repo-input"
                        placeholder="owner/repo"
                        aria-label="Repository in owner/repo format"
                    >
                </div>
                <button id="sync-btn" class="btn btn-primary">
                    Sync
                </button>
                <span id="auth-status" class="auth-status">Checking auth...</span>
            </div>
            <div class="controls-row secondary">
                <label class="comment-toggle" for="comment-prefetch-toggle">
                    <input type="checkbox" id="comment-prefetch-toggle">
                    Fetch comments for uninteresting filter
                </label>
                <label class="comment-expand" for="comment-expand-toggle">
                    <input type="checkbox" id="comment-expand-toggle">
                    Show unread comments
                </label>
                <label class="comment-hide" for="comment-hide-uninteresting-toggle">
                    <input type="checkbox" id="comment-hide-uninteresting-toggle">
                    Hide uninteresting comments
                </label>
                <div class="comment-cache-actions">
                    <span id="comment-cache-status" class="comment-cache-status"></span>
                    <button id="clear-comment-cache-btn" class="btn btn-small" type="button">
                        Clear cache
                    </button>
                </div>
            </div>
            <div id="status-bar" class="status-bar"></div>
            <div id="rate-limit-box" class="rate-limit-box">Rate limit: unknown</div>
        </section>

        <!-- Notifications Section -->
        <section class="notifications-container">
            <header class="notifications-header">
                <h2>Notifications</h2>
                <span id="notification-count"></span>
            </header>

            <nav class="filter-tabs" role="tablist" aria-label="Filter notifications">
                <button
                    class="filter-tab active"
                    role="tab"
                    aria-selected="true"
                    data-filter="all"
                    id="filter-all"
                >
                    All <span class="count" id="count-all">0</span>
                </button>
                <button
                    class="filter-tab"
                    role="tab"
                    aria-selected="false"
                    data-filter="open"
                    id="filter-open"
                >
                    Open <span class="count" id="count-open">0</span>
                </button>
                <button
                    class="filter-tab"
                    role="tab"
                    aria-selected="false"
                    data-filter="closed"
                    id="filter-closed"
                >
                    Closed <span class="count" id="count-closed">0</span>
                </button>
                <button
                    class="filter-tab"
                    role="tab"
                    aria-selected="false"
                    data-filter="uninteresting"
                    id="filter-uninteresting"
                >
                    Uninteresting <span class="count" id="count-uninteresting">0</span>
                </button>
            </nav>

            <div id="select-all-row" class="select-all-row" style="display: none;">
                <input
                    type="checkbox"
                    id="select-all-checkbox"
                    class="select-all-checkbox"
                    aria-label="Select all notifications"
                >
                <label for="select-all-checkbox" class="select-all-label">Select all</label>
                <span id="selection-count" class="selection-count"></span>
                <button id="mark-done-btn" class="btn btn-danger" style="display: none;">
                    Mark Done
                </button>
            </div>

            <div id="progress-container" class="progress-container">
                <div class="progress-bar-bg">
                    <div id="progress-bar-fill" class="progress-bar-fill" style="width: 0%;"></div>
                </div>
                <div id="progress-text" class="progress-text"></div>
            </div>

            <div id="loading" class="loading">
                Loading notifications...
            </div>

            <div id="empty-state" class="empty-state">
                <h3>No notifications</h3>
                <p>Enter a repository and click Sync to load notifications.</p>
            </div>

            <ul id="notifications-list" class="notifications-list" role="list">
                <!-- Notifications will be rendered here -->
            </ul>
        </section>
    </main>

    <script>
        const COMMENT_CACHE_KEY = 'ghnotif_bulk_comment_cache_v1';
        const COMMENT_CACHE_TTL_MS = 12 * 60 * 60 * 1000;
        const COMMENT_CONCURRENCY = 4;
        const COMMENT_PREFETCH_KEY = 'ghnotif_comment_prefetch_enabled';
        const COMMENT_EXPAND_KEY = 'ghnotif_comment_expand_enabled';
        const COMMENT_HIDE_UNINTERESTING_KEY = 'ghnotif_comment_hide_uninteresting';

        // Application state
        const state = {
            repo: null,
            notifications: [],
            loading: false,
            error: null,
            filter: 'all', // 'all', 'open', 'closed', 'uninteresting'
            selected: new Set(), // Set of selected notification IDs
            lastClickedId: null, // For shift-click range selection
            markingInProgress: false, // Whether Mark Done is in progress
            markProgress: { current: 0, total: 0 }, // Progress tracking
            commentPrefetchEnabled: false,
            commentExpandEnabled: false,
            commentHideUninteresting: false,
            commentQueue: [],
            commentQueueRunning: false,
            commentCache: loadCommentCache(),
            rateLimit: null,
            rateLimitError: null,
        };

        // DOM elements
        const elements = {
            repoInput: document.getElementById('repo-input'),
            syncBtn: document.getElementById('sync-btn'),
            authStatus: document.getElementById('auth-status'),
            statusBar: document.getElementById('status-bar'),
            commentPrefetchToggle: document.getElementById('comment-prefetch-toggle'),
            commentExpandToggle: document.getElementById('comment-expand-toggle'),
            commentHideUninterestingToggle: document.getElementById('comment-hide-uninteresting-toggle'),
            commentCacheStatus: document.getElementById('comment-cache-status'),
            clearCommentCacheBtn: document.getElementById('clear-comment-cache-btn'),
            rateLimitBox: document.getElementById('rate-limit-box'),
            loading: document.getElementById('loading'),
            emptyState: document.getElementById('empty-state'),
            notificationsList: document.getElementById('notifications-list'),
            notificationCount: document.getElementById('notification-count'),
            filterTabs: document.querySelectorAll('.filter-tab'),
            countAll: document.getElementById('count-all'),
            countOpen: document.getElementById('count-open'),
            countClosed: document.getElementById('count-closed'),
            countUninteresting: document.getElementById('count-uninteresting'),
            selectAllRow: document.getElementById('select-all-row'),
            selectAllCheckbox: document.getElementById('select-all-checkbox'),
            selectionCount: document.getElementById('selection-count'),
            markDoneBtn: document.getElementById('mark-done-btn'),
            progressContainer: document.getElementById('progress-container'),
            progressBarFill: document.getElementById('progress-bar-fill'),
            progressText: document.getElementById('progress-text'),
        };

        function loadCommentCache() {
            const raw = localStorage.getItem(COMMENT_CACHE_KEY);
            if (!raw) {
                return { version: 1, threads: {} };
            }
            try {
                return JSON.parse(raw);
            } catch (e) {
                console.error('Failed to parse comment cache:', e);
                return { version: 1, threads: {} };
            }
        }

        function saveCommentCache() {
            localStorage.setItem(COMMENT_CACHE_KEY, JSON.stringify(state.commentCache));
        }

        function isCommentCacheFresh(cached) {
            if (!cached?.fetchedAt) {
                return false;
            }
            const fetchedAtMs = Date.parse(cached.fetchedAt);
            if (Number.isNaN(fetchedAtMs)) {
                return false;
            }
            return Date.now() - fetchedAtMs < COMMENT_CACHE_TTL_MS;
        }

        // Initialize app
        function init() {
            // Load saved repo from localStorage
            const savedRepo = localStorage.getItem('ghnotif_repo');
            if (savedRepo) {
                elements.repoInput.value = savedRepo;
                state.repo = savedRepo;
            }

            // Load saved notifications from localStorage
            const savedNotifications = localStorage.getItem('ghnotif_notifications');
            if (savedNotifications) {
                try {
                    state.notifications = JSON.parse(savedNotifications);
                } catch (e) {
                    console.error('Failed to parse saved notifications:', e);
                }
            }

            // Load saved filter from localStorage
            const savedFilter = localStorage.getItem('ghnotif_filter');
            if (savedFilter && ['all', 'open', 'closed', 'uninteresting'].includes(savedFilter)) {
                state.filter = savedFilter;
            }

            const savedCommentPrefetch = localStorage.getItem(COMMENT_PREFETCH_KEY);
            if (savedCommentPrefetch === 'true') {
                state.commentPrefetchEnabled = true;
            }
            elements.commentPrefetchToggle.checked = state.commentPrefetchEnabled;

            const savedCommentExpand = localStorage.getItem(COMMENT_EXPAND_KEY);
            if (savedCommentExpand === 'true') {
                state.commentExpandEnabled = true;
            }
            elements.commentExpandToggle.checked = state.commentExpandEnabled;

            const savedCommentHideUninteresting = localStorage.getItem(COMMENT_HIDE_UNINTERESTING_KEY);
            if (savedCommentHideUninteresting === 'true') {
                state.commentHideUninteresting = true;
            }
            elements.commentHideUninterestingToggle.checked = state.commentHideUninteresting;

            // Set up event listeners
            elements.syncBtn.addEventListener('click', handleSync);
            elements.repoInput.addEventListener('input', handleRepoInput);
            elements.repoInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    handleSync();
                }
            });

            // Filter tab click handlers
            elements.filterTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const filter = tab.dataset.filter;
                    setFilter(filter);
                });
            });

            elements.commentPrefetchToggle.addEventListener('change', (event) => {
                setCommentPrefetchEnabled(event.target.checked);
            });
            elements.commentExpandToggle.addEventListener('change', (event) => {
                setCommentExpandEnabled(event.target.checked);
            });
            elements.commentHideUninterestingToggle.addEventListener('change', (event) => {
                setCommentHideUninteresting(event.target.checked);
            });
            elements.clearCommentCacheBtn.addEventListener('click', handleClearCommentCache);

            // Select all checkbox handler
            elements.selectAllCheckbox.addEventListener('change', handleSelectAll);

            // Mark Done button handler
            elements.markDoneBtn.addEventListener('click', handleMarkDone);

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyDown);

            // Check auth status
            checkAuth();
            refreshRateLimit();

            // Initial render
            render();
        }

        // Handle repo input changes
        function handleRepoInput() {
            const value = elements.repoInput.value.trim();
            state.repo = value || null;
            localStorage.setItem('ghnotif_repo', value);
        }

        function setCommentPrefetchEnabled(enabled) {
            state.commentPrefetchEnabled = enabled;
            localStorage.setItem(COMMENT_PREFETCH_KEY, String(enabled));
            if (!enabled) {
                render();
                return;
            }
            showStatus('Fetching comments for uninteresting filter...', 'info');
            ensureLastReadAtData(state.notifications)
                .then((notifications) => {
                    state.notifications = notifications;
                    localStorage.setItem(
                        'ghnotif_notifications',
                        JSON.stringify(notifications)
                    );
                    state.commentQueue = [];
                    scheduleCommentPrefetch(notifications);
                    render();
                })
                .catch((e) => {
                    showStatus(`Comment prefetch setup failed: ${e.message}`, 'error');
                    render();
                });
        }

        function setCommentExpandEnabled(enabled) {
            state.commentExpandEnabled = enabled;
            localStorage.setItem(COMMENT_EXPAND_KEY, String(enabled));
            render();
        }

        function setCommentHideUninteresting(enabled) {
            state.commentHideUninteresting = enabled;
            localStorage.setItem(COMMENT_HIDE_UNINTERESTING_KEY, String(enabled));
            render();
        }

        // Set the current filter
        function setFilter(filter) {
            if (!['all', 'open', 'closed', 'uninteresting'].includes(filter)) return;
            state.filter = filter;
            localStorage.setItem('ghnotif_filter', filter);
            if (filter === 'uninteresting' && !state.commentPrefetchEnabled) {
                showStatus('Enable comment fetching to evaluate uninteresting notifications.', 'info');
            }
            render();
        }

        // Get filtered notifications based on current filter
        function getFilteredNotifications() {
            if (state.filter === 'all') {
                return state.notifications;
            }
            return state.notifications.filter(notif => {
                const notifState = notif.subject.state;
                if (state.filter === 'open') {
                    return notifState === 'open' || notifState === 'draft';
                }
                if (state.filter === 'closed') {
                    return notifState === 'closed' || notifState === 'merged';
                }
                if (state.filter === 'uninteresting') {
                    return isNotificationUninteresting(notif);
                }
                return true;
            });
        }

        // Count notifications by filter category
        function getFilterCounts() {
            let open = 0;
            let closed = 0;
            let uninteresting = 0;
            state.notifications.forEach(notif => {
                const notifState = notif.subject.state;
                if (notifState === 'open' || notifState === 'draft') {
                    open++;
                } else if (notifState === 'closed' || notifState === 'merged') {
                    closed++;
                }
                if (isNotificationUninteresting(notif)) {
                    uninteresting++;
                }
            });
            return {
                all: state.notifications.length,
                open,
                closed,
                uninteresting,
            };
        }

        function updateCommentCacheStatus() {
            const cachedCount = Object.keys(state.commentCache.threads || {}).length;
            elements.clearCommentCacheBtn.disabled = cachedCount === 0;
            if (!state.commentPrefetchEnabled) {
                elements.commentCacheStatus.textContent = 'Comments: off';
                return;
            }
            elements.commentCacheStatus.textContent = `Comments cached: ${cachedCount}`;
        }

        function handleClearCommentCache() {
            state.commentCache = { version: 1, threads: {} };
            state.commentQueue = [];
            localStorage.removeItem(COMMENT_CACHE_KEY);
            if (state.commentPrefetchEnabled && state.notifications.length > 0) {
                scheduleCommentPrefetch(state.notifications);
                showStatus('Comment cache cleared. Refetching comments...', 'info');
            } else {
                showStatus('Comment cache cleared.', 'success');
            }
            render();
        }

        function formatRateLimit(rateLimit, error) {
            if (error) {
                return `Rate limit error: ${error}`;
            }
            if (!rateLimit?.resources?.core) {
                return 'Rate limit: unknown';
            }
            const core = rateLimit.resources.core;
            const resetAt = core.reset
                ? new Date(core.reset * 1000).toLocaleTimeString()
                : 'unknown';
            return `Rate limit: ${core.remaining}/${core.limit} reset @ ${resetAt}`;
        }

        function updateRateLimitBox() {
            elements.rateLimitBox.textContent = formatRateLimit(
                state.rateLimit,
                state.rateLimitError
            );
        }

        async function refreshRateLimit() {
            try {
                const response = await fetch('/github/rest/rate_limit');
                if (!response.ok) {
                    throw new Error(`Request failed (${response.status})`);
                }
                const data = await response.json();
                state.rateLimit = data;
                state.rateLimitError = null;
            } catch (error) {
                state.rateLimitError = error.message || String(error);
            }
            updateRateLimitBox();
        }

        function getNotificationKey(notification) {
            return String(notification.id);
        }

        function getIssueNumber(notification) {
            const number = notification?.subject?.number;
            return typeof number === 'number' ? number : null;
        }

        function getNotificationMatchKey(notification) {
            const repo = parseRepoInput(state.repo || '');
            const number = notification?.subject?.number;
            const type = notification?.subject?.type || 'unknown';
            if (repo && typeof number === 'number') {
                return `${repo.owner}/${repo.repo}:${type}:${number}`;
            }
            return `id:${getNotificationKey(notification)}`;
        }

        function getRestNotificationMatchKey(notification) {
            const repo = notification?.repository?.full_name;
            const type = notification?.subject?.type || 'unknown';
            const url = notification?.subject?.url || '';
            const match = url.match(/\/(issues|pulls)\/(\d+)/);
            if (!repo || !match) {
                return null;
            }
            return `${repo}:${type}:${match[2]}`;
        }

        async function fetchJson(url) {
            const response = await fetch(url);
            if (!response.ok) {
                let detail = '';
                try {
                    detail = await response.text();
                } catch (error) {
                    detail = String(error);
                }
                throw new Error(`Request failed: ${url} (${response.status}) ${detail}`);
            }
            return response.json();
        }

        async function fetchRestNotificationsMap(targetKeys) {
            const result = new Map();
            const maxPages = 5;
            for (let page = 1; page <= maxPages; page += 1) {
                const params = new URLSearchParams();
                params.set('all', 'true');
                params.set('per_page', '50');
                params.set('page', String(page));
                const url = `/github/rest/notifications?${params}`;
                let payload = [];
                try {
                    payload = await fetchJson(url);
                } catch (error) {
                    showStatus(`Rate limit fetch failed: ${error.message || error}`, 'error');
                    break;
                }
                if (!Array.isArray(payload) || payload.length === 0) {
                    break;
                }
                payload.forEach((notif) => {
                    const key = getRestNotificationMatchKey(notif);
                    if (key && targetKeys.has(key)) {
                        result.set(key, notif);
                    }
                });
                const remaining = [...targetKeys].filter((id) => !result.has(id));
                if (remaining.length === 0) {
                    break;
                }
            }
            return result;
        }

        async function ensureLastReadAtData(notifications) {
            const missing = notifications.filter((notif) => !notif.last_read_at);
            if (!missing.length) {
                return notifications;
            }
            const cachedLastReadAt = new Map();
            missing.forEach((notif) => {
                const cached = state.commentCache.threads[getNotificationKey(notif)];
                if (cached?.lastReadAt && isCommentCacheFresh(cached)) {
                    cachedLastReadAt.set(getNotificationKey(notif), cached.lastReadAt);
                }
            });
            const missingKeys = new Set();
            missing.forEach((notif) => {
                if (cachedLastReadAt.has(getNotificationKey(notif))) {
                    return;
                }
                const key = getNotificationMatchKey(notif);
                if (key) {
                    missingKeys.add(key);
                }
            });
            const restMap =
                missingKeys.size > 0
                    ? await fetchRestNotificationsMap(missingKeys)
                    : new Map();
            const mergedNotifications = notifications.map((notif) => {
                const lastReadAtMissing = !notif.last_read_at;
                const cached = cachedLastReadAt.get(getNotificationKey(notif));
                if (cached && lastReadAtMissing) {
                    return { ...notif, last_read_at: cached, last_read_at_missing: true };
                }
                const rest = restMap.get(getNotificationMatchKey(notif));
                if (rest && rest.last_read_at && lastReadAtMissing) {
                    return {
                        ...notif,
                        last_read_at: rest.last_read_at,
                        last_read_at_missing: true,
                    };
                }
                if (lastReadAtMissing) {
                    return { ...notif, last_read_at_missing: true };
                }
                return notif;
            });
            await refreshRateLimit();
            return mergedNotifications;
        }

        function scheduleCommentPrefetch(notifications) {
            if (!state.commentPrefetchEnabled) {
                return;
            }
            notifications.forEach((notif) => {
                state.commentQueue.push(() => prefetchNotificationComments(notif));
            });
            runCommentQueue();
        }

        async function runCommentQueue() {
            if (state.commentQueueRunning) {
                return;
            }
            state.commentQueueRunning = true;
            while (state.commentQueue.length) {
                const batch = state.commentQueue.splice(0, COMMENT_CONCURRENCY);
                await Promise.all(batch.map((task) => task()));
                saveCommentCache();
                render();
            }
            await refreshRateLimit();
            state.commentQueueRunning = false;
        }

        function toIssueComment(issue) {
            if (!issue) {
                return null;
            }
            return {
                id: issue.id || `issue-${issue.number || 'unknown'}`,
                user: issue.user,
                body: issue.body ?? '',
                created_at: issue.created_at,
                updated_at: issue.updated_at,
                isIssue: true,
            };
        }

        async function fetchAllIssueComments(repo, issueNumber) {
            const issueUrl = `/github/rest/repos/${encodeURIComponent(repo.owner)}/${encodeURIComponent(repo.repo)}/issues/${issueNumber}`;
            let issue = null;
            try {
                issue = await fetchJson(issueUrl);
            } catch (error) {
                issue = null;
            }
            const commentUrl = `/github/rest/repos/${encodeURIComponent(repo.owner)}/${encodeURIComponent(repo.repo)}/issues/${issueNumber}/comments`;
            const commentPayload = await fetchJson(commentUrl);
            const comments = [];
            const issueComment = toIssueComment(issue);
            if (issueComment) {
                comments.push(issueComment);
            }
            if (Array.isArray(commentPayload)) {
                comments.push(...commentPayload);
            }
            return comments;
        }

        async function prefetchNotificationComments(notification) {
            const threadId = getNotificationKey(notification);
            const cached = state.commentCache.threads[threadId];
            const shouldLoadAllComments = Boolean(
                notification.last_read_at_missing || !notification.last_read_at
            );
            if (
                cached &&
                cached.notificationUpdatedAt === notification.updated_at &&
                isCommentCacheFresh(cached) &&
                ((shouldLoadAllComments && cached.allComments) ||
                    (!shouldLoadAllComments &&
                        cached.lastReadAt === (notification.last_read_at || null)))
            ) {
                return;
            }

            const issueNumber = getIssueNumber(notification);
            if (!issueNumber) {
                state.commentCache.threads[threadId] = {
                    notificationUpdatedAt: notification.updated_at,
                    comments: [],
                    error: 'No issue number found.',
                    fetchedAt: new Date().toISOString(),
                };
                return;
            }

            try {
                const repo = parseRepoInput(state.repo || '');
                if (!repo) {
                    throw new Error('Missing repository input.');
                }
                let lastReadAt = null;
                let allComments = false;
                let comments = [];
                if (shouldLoadAllComments) {
                    allComments = true;
                    comments = await fetchAllIssueComments(repo, issueNumber);
                } else {
                    lastReadAt = notification.last_read_at || cached?.lastReadAt || null;
                    if (!lastReadAt) {
                        allComments = true;
                        comments = await fetchAllIssueComments(repo, issueNumber);
                    } else {
                        let commentUrl = `/github/rest/repos/${encodeURIComponent(repo.owner)}/${encodeURIComponent(repo.repo)}/issues/${issueNumber}/comments`;
                        commentUrl += `?since=${encodeURIComponent(lastReadAt)}`;
                        comments = await fetchJson(commentUrl);
                    }
                }

                state.commentCache.threads[threadId] = {
                    notificationUpdatedAt: notification.updated_at,
                    lastReadAt,
                    unread: notification.unread,
                    comments,
                    allComments,
                    fetchedAt: new Date().toISOString(),
                };
            } catch (error) {
                state.commentCache.threads[threadId] = {
                    notificationUpdatedAt: notification.updated_at,
                    comments: [],
                    allComments: shouldLoadAllComments,
                    error: error.message || String(error),
                    fetchedAt: new Date().toISOString(),
                };
            }
        }

        function getCommentStatus(notification) {
            const cached = state.commentCache.threads[getNotificationKey(notification)];
            if (!state.commentPrefetchEnabled) {
                return { label: 'Comments: off', className: 'off' };
            }
            if (!cached) {
                return { label: 'Comments: pending', className: 'pending' };
            }
            if (cached.error) {
                return { label: 'Comments: error', className: 'error' };
            }
            const count = cached.comments ? cached.comments.length : 0;
            if (count === 0) {
                return { label: 'Uninteresting (0)', className: 'uninteresting' };
            }
            if (isNotificationUninteresting(notification)) {
                return { label: `Uninteresting (${count})`, className: 'uninteresting' };
            }
            return { label: `Interesting (${count})`, className: 'interesting' };
        }

        function getCommentItems(notification) {
            if (!state.commentExpandEnabled) {
                return '';
            }
            if (!state.commentPrefetchEnabled) {
                return '<li class="comment-item">Enable comment fetching to show comments.</li>';
            }
            const cached = state.commentCache.threads[getNotificationKey(notification)];
            if (!cached) {
                return '<li class="comment-item">Comments: pending...</li>';
            }
            if (cached.error) {
                return `<li class="comment-item">Comments error: ${escapeHtml(cached.error)}</li>`;
            }
            const comments = cached.comments || [];
            if (comments.length === 0) {
                const label = cached.allComments ? 'No comments found.' : 'No unread comments found.';
                return `<li class="comment-item">${label}</li>`;
            }
            const visibleComments = state.commentHideUninteresting
                ? comments.filter((comment) => !isUninterestingComment(comment))
                : comments;
            if (visibleComments.length === 0) {
                return '<li class="comment-item">No interesting unread comments found.</li>';
            }
            return visibleComments
                .map((comment) => {
                    const author = comment.user?.login || 'unknown';
                    const timestamp = comment.updated_at || comment.created_at || '';
                    const body = (comment.body || '').slice(0, 600);
                    return `
                        <li class="comment-item">
                            <div class="comment-meta">
                                <span>${escapeHtml(author)}</span>
                                <span>${escapeHtml(new Date(timestamp).toLocaleString())}</span>
                            </div>
                            <div>${escapeHtml(body)}</div>
                        </li>
                    `;
                })
                .join('');
        }

        function isNotificationUninteresting(notification) {
            if (!state.commentPrefetchEnabled) {
                return false;
            }
            const cached = state.commentCache.threads[getNotificationKey(notification)];
            if (!cached || cached.error) {
                return false;
            }
            const comments = cached.comments || [];
            if (comments.length === 0) {
                return true;
            }
            return comments.every(isUninterestingComment);
        }

        function isUninterestingComment(comment) {
            const body = String(comment?.body || '');
            if (isRevertRelated(body)) {
                return false;
            }
            const author = comment?.user?.login || '';
            if (isBotAuthor(author)) {
                return true;
            }
            return isBotInteractionComment(body);
        }

        function isRevertRelated(body) {
            return /\brevert(ed|ing)?\b/i.test(body) || /\brollback\b/i.test(body);
        }

        function isBotAuthor(login) {
            if (!login) {
                return false;
            }
            const normalized = login.toLowerCase();
            if (normalized.endsWith('[bot]')) {
                return true;
            }
            const knownBots = new Set([
                'dr-ci',
                'dr-ci-bot',
                'bors',
                'homu',
                'mergify',
                'htmlpurifierbot',
                'github-actions',
                'dependabot',
                'dependabot-preview',
            ]);
            return knownBots.has(normalized);
        }

        function isBotInteractionComment(body) {
            const lines = String(body || '')
                .split(/\r?\n/)
                .map((line) => line.trim())
                .filter(Boolean);
            if (lines.length === 0) {
                return false;
            }
            const patterns = [
                /^\/(label|unlabel|merge|close|reopen|rebase|retry|rerun|retest|backport|cherry-pick|assign|unassign|cc|triage|priority|kind|lgtm|r\+)\b/i,
                /^bors\b/i,
                /^@?bors\b/i,
                /^@?homu\b/i,
                /^@?mergify\b/i,
                /^@?dr[-.\s]?ci\b/i,
                /^r\+$/i,
            ];
            return lines.every((line) => patterns.some((pattern) => pattern.test(line)));
        }

        // Handle select all checkbox
        function handleSelectAll() {
            const filtered = getFilteredNotifications();
            const allSelected = filtered.every(n => state.selected.has(n.id));

            if (allSelected) {
                // Deselect all filtered
                filtered.forEach(n => state.selected.delete(n.id));
            } else {
                // Select all filtered
                filtered.forEach(n => state.selected.add(n.id));
            }

            state.lastClickedId = null;
            render();
        }

        // Handle individual notification checkbox click
        function handleNotificationCheckbox(notifId, event) {
            const filtered = getFilteredNotifications();

            if (event.shiftKey && state.lastClickedId) {
                // Shift-click: select range
                selectRange(state.lastClickedId, notifId, filtered);
            } else {
                // Regular click: toggle single
                toggleSelection(notifId);
            }

            state.lastClickedId = notifId;
            render();
        }

        // Toggle a single notification's selection
        function toggleSelection(notifId) {
            if (state.selected.has(notifId)) {
                state.selected.delete(notifId);
            } else {
                state.selected.add(notifId);
            }
        }

        // Select a range of notifications (for shift-click)
        function selectRange(fromId, toId, notifications) {
            const ids = notifications.map(n => n.id);
            const fromIndex = ids.indexOf(fromId);
            const toIndex = ids.indexOf(toId);

            if (fromIndex === -1 || toIndex === -1) return;

            const start = Math.min(fromIndex, toIndex);
            const end = Math.max(fromIndex, toIndex);

            for (let i = start; i <= end; i++) {
                state.selected.add(ids[i]);
            }
        }

        // Clear all selections
        function clearSelection() {
            state.selected.clear();
            state.lastClickedId = null;
            render();
        }

        // Handle Mark Done button click
        async function handleMarkDone() {
            if (state.selected.size === 0 || state.markingInProgress) return;

            const selectedIds = Array.from(state.selected);

            // Confirm if marking many items
            if (selectedIds.length >= 10) {
                const confirmed = confirm(
                    `Are you sure you want to mark ${selectedIds.length} notifications as done?`
                );
                if (!confirmed) return;
            }

            state.markingInProgress = true;
            state.markProgress = { current: 0, total: selectedIds.length };

            // Disable UI during operation
            elements.markDoneBtn.disabled = true;
            elements.selectAllCheckbox.disabled = true;
            render();

            const successfulIds = [];
            const failedResults = []; // Store {id, error} for detailed reporting
            let rateLimitDelay = 0;

            for (let i = 0; i < selectedIds.length; i++) {
                const notifId = selectedIds[i];
                state.markProgress.current = i + 1;
                render();

                // If we hit a rate limit, wait before retrying
                if (rateLimitDelay > 0) {
                    await sleep(rateLimitDelay);
                    rateLimitDelay = 0;
                }

                try {
                    const result = await markNotificationDone(notifId);

                    if (result.rateLimited) {
                        // Rate limited - wait and retry
                        rateLimitDelay = result.retryAfter || 60000;
                        showStatus(`Rate limited. Waiting ${Math.ceil(rateLimitDelay / 1000)}s...`, 'info');
                        i--; // Retry this item
                        continue;
                    }

                    if (result.success) {
                        successfulIds.push(notifId);
                    } else {
                        const errorDetail = result.error || `HTTP ${result.status || 'unknown'}`;
                        console.error(`[MarkDone] Failed for ${notifId}:`, errorDetail);
                        failedResults.push({ id: notifId, error: errorDetail });
                    }
                } catch (e) {
                    const errorDetail = e.message || String(e);
                    console.error(`[MarkDone] Exception for ${notifId}:`, e);
                    failedResults.push({ id: notifId, error: errorDetail });
                }

                // Small delay between requests to avoid rate limiting
                if (i < selectedIds.length - 1) {
                    await sleep(100);
                }
            }

            // Remove successfully marked notifications from state
            state.notifications = state.notifications.filter(
                n => !successfulIds.includes(n.id)
            );

            // Clear selection for successful items
            successfulIds.forEach(id => state.selected.delete(id));

            // Update localStorage
            localStorage.setItem('ghnotif_notifications', JSON.stringify(state.notifications));

            // Reset marking state
            state.markingInProgress = false;
            state.markProgress = { current: 0, total: 0 };
            elements.markDoneBtn.disabled = false;
            elements.selectAllCheckbox.disabled = false;

            // Show result message with details
            if (failedResults.length === 0) {
                showStatus(`Marked ${successfulIds.length} notification${successfulIds.length !== 1 ? 's' : ''} as done`, 'success');
            } else if (successfulIds.length === 0) {
                // All failed - show first error for context
                const firstError = failedResults[0].error;
                showStatus(`Failed to mark notifications: ${firstError}`, 'error');
                console.error('[MarkDone] All failed. Errors:', failedResults);
            } else {
                // Partial failure
                const firstError = failedResults[0].error;
                showStatus(`Marked ${successfulIds.length} done, ${failedResults.length} failed: ${firstError}`, 'error');
                console.error('[MarkDone] Partial failure. Errors:', failedResults);
            }

            await refreshRateLimit();
            render();
        }

        // Sleep helper for delays
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Check if ID is a GitHub node ID (starts with prefix like NT_, PR_, etc.)
        function isNodeId(id) {
            return typeof id === 'string' && /^[A-Z]+_/.test(id);
        }

        // Extract REST API thread_id from a GitHub node ID
        // Node IDs are base64 encoded and contain "thread_id:user_id"
        function extractThreadIdFromNodeId(nodeId) {
            if (!nodeId.startsWith('NT_')) {
                return null;
            }

            try {
                const suffix = nodeId.slice(3); // Remove 'NT_'
                // Base64 decode
                const decoded = atob(suffix);
                // Extract thread_id:user_id pattern (the numeric part after binary prefix)
                const match = decoded.match(/(\d{10,}):\d+/);
                if (match) {
                    return match[1];
                }
            } catch (e) {
                console.error(`[MarkDone] Failed to decode node ID ${nodeId}:`, e);
            }

            return null;
        }

        // Mark a single notification as done using the REST API
        async function markNotificationDone(notifId) {
            console.log(`[MarkDone] Attempting to mark notification: ${notifId}`);

            let threadId = notifId;

            // If it's a node ID, extract the REST API thread_id
            if (isNodeId(notifId)) {
                console.log(`[MarkDone] ID is a node ID, extracting thread_id...`);
                const extracted = extractThreadIdFromNodeId(notifId);
                if (!extracted) {
                    const error = `Failed to extract thread_id from node ID: ${notifId}`;
                    console.error(`[MarkDone] ${error}`);
                    return { success: false, error };
                }
                threadId = extracted;
                console.log(`[MarkDone] Extracted thread_id: ${threadId}`);
            }

            // Use REST API with the thread_id
            // DELETE marks as "Done", PATCH only marks as "Read"
            const url = `/github/rest/notifications/threads/${threadId}`;
            console.log(`[MarkDone] REST request: DELETE ${url}`);

            const response = await fetch(url, {
                method: 'DELETE',
            });

            console.log(`[MarkDone] REST response status: ${response.status} ${response.statusText}`);

            if (response.status === 429) {
                const retryAfter = response.headers.get('Retry-After');
                console.warn(`[MarkDone] Rate limited, retry after: ${retryAfter}s`);
                return {
                    success: false,
                    rateLimited: true,
                    retryAfter: retryAfter ? parseInt(retryAfter, 10) * 1000 : 60000
                };
            }

            // DELETE returns 204 No Content on success
            if (!response.ok && response.status !== 204) {
                const responseText = await response.text();
                const error = `REST error: ${response.status} ${response.statusText}`;
                console.error(`[MarkDone] ${error}`, responseText);
                return { success: false, error, status: response.status, responseBody: responseText };
            }

            console.log(`[MarkDone] REST success for ${notifId} (thread_id: ${threadId})`);
            return { success: true };
        }

        // Handle inline Mark Done button click for a single notification
        async function handleInlineMarkDone(notifId, button) {
            if (state.markingInProgress) return;

            button.disabled = true;

            try {
                const result = await markNotificationDone(notifId);

                if (result.rateLimited) {
                    showStatus('Rate limited. Please try again shortly.', 'info');
                    button.disabled = false;
                    return;
                }

                if (!result.success) {
                    const errorDetail = result.error || `HTTP ${result.status || 'unknown'}`;
                    showStatus(`Failed to mark notification: ${errorDetail}`, 'error');
                    button.disabled = false;
                    return;
                }

                state.notifications = state.notifications.filter(
                    n => n.id !== notifId
                );
                state.selected.delete(notifId);
                localStorage.setItem('ghnotif_notifications', JSON.stringify(state.notifications));

                showStatus('Marked 1 notification as done', 'success');
            } catch (e) {
                const errorDetail = e.message || String(e);
                showStatus(`Failed to mark notification: ${errorDetail}`, 'error');
                button.disabled = false;
                return;
            }

            await refreshRateLimit();
            render();
        }

        // Handle keyboard shortcuts
        function handleKeyDown(e) {
            // Don't handle shortcuts when typing in inputs
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            // Escape: Clear selection
            if (e.key === 'Escape' && state.selected.size > 0) {
                clearSelection();
                e.preventDefault();
            }

            // Ctrl/Cmd + A: Select all (when notifications exist)
            if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                const filtered = getFilteredNotifications();
                if (filtered.length > 0 && !state.markingInProgress) {
                    e.preventDefault();
                    filtered.forEach(n => state.selected.add(n.id));
                    render();
                }
            }
        }

        // Get appropriate empty state message
        function getEmptyStateMessage() {
            if (state.notifications.length === 0) {
                return {
                    title: 'No notifications',
                    message: 'Enter a repository and click Sync to load notifications.',
                };
            }

            // Have notifications but filter shows none
            if (state.filter === 'open') {
                return {
                    title: 'No open notifications',
                    message: 'All notifications in this repository are closed or merged.',
                };
            }

            if (state.filter === 'closed') {
                return {
                    title: 'No closed notifications',
                    message: 'All notifications in this repository are still open.',
                };
            }

            if (state.filter === 'uninteresting') {
                if (!state.commentPrefetchEnabled) {
                    return {
                        title: 'Comment fetching disabled',
                        message: 'Enable comment fetching to evaluate uninteresting notifications.',
                    };
                }
                return {
                    title: 'No uninteresting notifications',
                    message: 'All recent comments include something worth a look.',
                };
            }

            return {
                title: 'No notifications',
                message: 'No notifications match the current filter.',
            };
        }

        // Check authentication status
        async function checkAuth() {
            try {
                const response = await fetch('/github/rest/user');
                const data = await response.json();

                if (response.ok && data.login) {
                    elements.authStatus.textContent = `Signed in as ${data.login}`;
                    elements.authStatus.className = 'auth-status authenticated';
                } else {
                    elements.authStatus.textContent = 'Not authenticated';
                    elements.authStatus.className = 'auth-status error';
                }
            } catch (e) {
                elements.authStatus.textContent = 'Auth check failed';
                elements.authStatus.className = 'auth-status error';
            }
        }

        // Handle sync button click
        async function handleSync() {
            const repo = elements.repoInput.value.trim();
            if (!repo) {
                showStatus('Please enter a repository (owner/repo)', 'error');
                return;
            }

            // Parse owner/repo
            const parts = repo.split('/');
            if (parts.length !== 2) {
                showStatus('Invalid format. Use owner/repo', 'error');
                return;
            }

            const [owner, repoName] = parts;
            const previousNotifications = state.notifications.slice();
            const previousSelected = new Set(state.selected);
            state.loading = true;
            state.error = null;
            state.notifications = [];
            state.selected.clear();
            render();

            showStatus('Syncing notifications...', 'info');

            try {
                const allNotifications = [];
                let afterCursor = null;
                let pageCount = 0;

                // Fetch all pages
                do {
                    pageCount++;
                    showStatus(`Syncing page ${pageCount}...`, 'info');

                    let url = `/notifications/html/repo/${encodeURIComponent(owner)}/${encodeURIComponent(repoName)}`;
                    if (afterCursor) {
                        url += `?after=${encodeURIComponent(afterCursor)}`;
                    }

                    const response = await fetch(url);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.detail || `HTTP ${response.status}`);
                    }

                    const data = await response.json();
                    allNotifications.push(...data.notifications);
                    afterCursor = data.pagination.has_next ? data.pagination.after_cursor : null;
                    state.notifications = allNotifications.slice();
                    render();

                } while (afterCursor);

                // Sort by updated_at descending
                const sortedNotifications = allNotifications.sort((a, b) =>
                    new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()
                );

                let notifications = sortedNotifications;
                if (state.commentPrefetchEnabled) {
                    notifications = await ensureLastReadAtData(sortedNotifications);
                }

                state.notifications = notifications;
                state.loading = false;

                // Save to localStorage
                localStorage.setItem('ghnotif_notifications', JSON.stringify(notifications));

                if (state.commentPrefetchEnabled) {
                    state.commentQueue = [];
                    scheduleCommentPrefetch(notifications);
                }

                showStatus(`Synced ${notifications.length} notifications`, 'success');
                render();

            } catch (e) {
                state.loading = false;
                state.error = e.message;
                state.notifications = previousNotifications;
                state.selected = previousSelected;
                showStatus(`Sync failed: ${e.message}`, 'error');
                render();
            }
        }

        // Show status message
        function showStatus(message, type) {
            elements.statusBar.textContent = message;
            elements.statusBar.className = `status-bar visible ${type}`;
        }

        // SVG Icons
        const icons = {
            issue: `<svg viewBox="0 0 16 16" fill="currentColor"><path d="M8 9.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z"></path><path d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Z"></path></svg>`,
            issueClosed: `<svg viewBox="0 0 16 16" fill="currentColor"><path d="M11.28 6.78a.75.75 0 0 0-1.06-1.06L7.25 8.69 5.78 7.22a.75.75 0 0 0-1.06 1.06l2 2a.75.75 0 0 0 1.06 0l3.5-3.5Z"></path><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0Zm-1.5 0a6.5 6.5 0 1 0-13 0 6.5 6.5 0 0 0 13 0Z"></path></svg>`,
            issueNotPlanned: `<svg viewBox="0 0 16 16" fill="currentColor"><path d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Zm9.78-2.22-5.5 5.5a.749.749 0 0 1-1.275-.326.749.749 0 0 1 .215-.734l5.5-5.5a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042Z"></path></svg>`,
            pr: `<svg viewBox="0 0 16 16" fill="currentColor"><path d="M1.5 3.25a2.25 2.25 0 1 1 3 2.122v5.256a2.251 2.251 0 1 1-1.5 0V5.372A2.25 2.25 0 0 1 1.5 3.25Zm5.677-.177L9.573.677A.25.25 0 0 1 10 .854V2.5h1A2.5 2.5 0 0 1 13.5 5v5.628a2.251 2.251 0 1 1-1.5 0V5a1 1 0 0 0-1-1h-1v1.646a.25.25 0 0 1-.427.177L7.177 3.427a.25.25 0 0 1 0-.354ZM3.75 2.5a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm0 9.5a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm8.25.75a.75.75 0 1 0 1.5 0 .75.75 0 0 0-1.5 0Z"></path></svg>`,
            prMerged: `<svg viewBox="0 0 16 16" fill="currentColor"><path d="M5.45 5.154A4.25 4.25 0 0 0 9.25 7.5h1.378a2.251 2.251 0 1 1 0 1.5H9.25A5.734 5.734 0 0 1 5 7.123v3.505a2.25 2.25 0 1 1-1.5 0V5.372a2.25 2.25 0 1 1 1.95-.218ZM4.25 13.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Zm8.5-4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5ZM5 3.25a.75.75 0 1 0 0 .005V3.25Z"></path></svg>`,
            prClosed: `<svg viewBox="0 0 16 16" fill="currentColor"><path d="M3.25 1A2.25 2.25 0 0 1 4 5.372v5.256a2.251 2.251 0 1 1-1.5 0V5.372A2.251 2.251 0 0 1 3.25 1Zm9.5 5.5a.75.75 0 0 1 .75.75v3.378a2.251 2.251 0 1 1-1.5 0V7.25a.75.75 0 0 1 .75-.75Zm-2.03-5.28a.75.75 0 0 1 1.06 0l2 2a.75.75 0 0 1 0 1.06l-2 2a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l.94-.94-2.94.001a1 1 0 0 0-1 1v2.5a.75.75 0 0 1-1.5 0V5.251a2.5 2.5 0 0 1 2.5-2.5l2.94-.001-.94-.94a.75.75 0 0 1 0-1.06ZM3.25 12.5a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm9.5 0a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Z"></path></svg>`,
            prDraft: `<svg viewBox="0 0 16 16" fill="currentColor"><path d="M3.25 1A2.25 2.25 0 0 1 4 5.372v5.256a2.251 2.251 0 1 1-1.5 0V5.372A2.251 2.251 0 0 1 3.25 1Zm9.5 14a2.25 2.25 0 1 1 0-4.5 2.25 2.25 0 0 1 0 4.5ZM3.25 12.5a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm9.5 0a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5ZM14 7.5a1.25 1.25 0 1 1-2.5 0 1.25 1.25 0 0 1 2.5 0Zm0-4.25a1.25 1.25 0 1 1-2.5 0 1.25 1.25 0 0 1 2.5 0Z"></path></svg>`,
            discussion: `<svg viewBox="0 0 16 16" fill="currentColor"><path d="M1.75 1h8.5c.966 0 1.75.784 1.75 1.75v5.5A1.75 1.75 0 0 1 10.25 10H7.061l-2.574 2.573A1.458 1.458 0 0 1 2 11.543V10h-.25A1.75 1.75 0 0 1 0 8.25v-5.5C0 1.784.784 1 1.75 1ZM1.5 2.75v5.5c0 .138.112.25.25.25h1a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h3.5a.25.25 0 0 0 .25-.25v-5.5a.25.25 0 0 0-.25-.25h-8.5a.25.25 0 0 0-.25.25Zm13 2a.25.25 0 0 0-.25-.25h-.5a.75.75 0 0 1 0-1.5h.5c.966 0 1.75.784 1.75 1.75v5.5A1.75 1.75 0 0 1 14.25 12H14v1.543a1.458 1.458 0 0 1-2.487 1.03L9.22 12.28a.749.749 0 0 1 .326-1.275.749.749 0 0 1 .734.215l2.22 2.22v-2.19a.75.75 0 0 1 .75-.75h1a.25.25 0 0 0 .25-.25Z"></path></svg>`,
            commit: `<svg viewBox="0 0 16 16" fill="currentColor"><path d="M11.93 8.5a4.002 4.002 0 0 1-7.86 0H.75a.75.75 0 0 1 0-1.5h3.32a4.002 4.002 0 0 1 7.86 0h3.32a.75.75 0 0 1 0 1.5Zm-1.43-.75a2.5 2.5 0 1 0-5 0 2.5 2.5 0 0 0 5 0Z"></path></svg>`,
            release: `<svg viewBox="0 0 16 16" fill="currentColor"><path d="M1 7.775V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 0 1 0 2.474l-5.026 5.026a1.75 1.75 0 0 1-2.474 0l-6.25-6.25A1.752 1.752 0 0 1 1 7.775Zm1.5 0c0 .066.026.13.073.177l6.25 6.25a.25.25 0 0 0 .354 0l5.025-5.025a.25.25 0 0 0 0-.354l-6.25-6.25a.25.25 0 0 0-.177-.073H2.75a.25.25 0 0 0-.25.25ZM6 5a1 1 0 1 1 0 2 1 1 0 0 1 0-2Z"></path></svg>`,
            check: `<svg viewBox="0 0 16 16" fill="currentColor"><path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path></svg>`,
        };

        // Get icon for notification type and state
        function getNotificationIcon(notif) {
            const type = notif.subject.type;
            const state = notif.subject.state;
            const stateReason = notif.subject.state_reason;

            if (type === 'Issue') {
                if (state === 'closed') {
                    if (stateReason === 'not_planned') return icons.issueNotPlanned;
                    return icons.issueClosed;
                }
                return icons.issue;
            }
            if (type === 'PullRequest') {
                if (state === 'merged') return icons.prMerged;
                if (state === 'closed') return icons.prClosed;
                if (state === 'draft') return icons.prDraft;
                return icons.pr;
            }
            if (type === 'Discussion') return icons.discussion;
            if (type === 'Commit') return icons.commit;
            if (type === 'Release') return icons.release;
            return icons.issue; // fallback
        }

        // Get icon state class
        function getIconStateClass(notif) {
            const state = notif.subject.state;
            if (state === 'merged') return 'merged';
            if (state === 'closed') return 'closed';
            if (state === 'draft') return 'draft';
            return 'open';
        }

        // Format relative time
        function formatRelativeTime(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffMs = now - date;
            const diffSecs = Math.floor(diffMs / 1000);
            const diffMins = Math.floor(diffSecs / 60);
            const diffHours = Math.floor(diffMins / 60);
            const diffDays = Math.floor(diffHours / 24);
            const diffWeeks = Math.floor(diffDays / 7);
            const diffMonths = Math.floor(diffDays / 30);
            const diffYears = Math.floor(diffDays / 365);

            if (diffSecs < 60) return 'just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            if (diffWeeks < 4) return `${diffWeeks}w ago`;
            if (diffMonths < 12) return `${diffMonths}mo ago`;
            return `${diffYears}y ago`;
        }

        // Format reason for display
        function formatReason(reason) {
            const reasonMap = {
                'author': 'Author',
                'comment': 'Comment',
                'mention': 'Mentioned',
                'review_requested': 'Review requested',
                'subscribed': 'Subscribed',
                'team_mention': 'Team mentioned',
                'assign': 'Assigned',
                'state_change': 'State change',
                'ci_activity': 'CI activity',
            };
            return reasonMap[reason] || reason;
        }

        // Get state badge HTML
        function getStateBadge(notif) {
            const type = notif.subject.type;
            const state = notif.subject.state;
            const stateReason = notif.subject.state_reason;

            if (!state) return '';

            let label = state.charAt(0).toUpperCase() + state.slice(1);
            let cssClass = state;

            if (state === 'closed' && stateReason === 'completed') {
                cssClass = 'closed completed';
            }

            if (type === 'PullRequest' && state === 'merged') {
                label = 'Merged';
            }

            return `<span class="state-badge ${cssClass}" data-state="${state}">${label}</span>`;
        }

        // Render the UI
        function render() {
            // Show/hide loading state
            elements.loading.className = state.loading ? 'loading visible' : 'loading';

            // Get filtered notifications
            const filteredNotifications = getFilteredNotifications();

            // Show/hide empty state with dynamic message
            const showEmpty = !state.loading && filteredNotifications.length === 0;
            elements.emptyState.style.display = showEmpty ? 'block' : 'none';
            if (showEmpty) {
                const emptyMsg = getEmptyStateMessage();
                elements.emptyState.innerHTML = `
                    <h3>${emptyMsg.title}</h3>
                    <p>${emptyMsg.message}</p>
                `;
            }

            // Update filter tab counts and active state
            const counts = getFilterCounts();
            elements.countAll.textContent = counts.all;
            elements.countOpen.textContent = counts.open;
            elements.countClosed.textContent = counts.closed;
            elements.countUninteresting.textContent = counts.uninteresting;
            updateCommentCacheStatus();

            // Update filter tab active states
            elements.filterTabs.forEach(tab => {
                const isActive = tab.dataset.filter === state.filter;
                tab.classList.toggle('active', isActive);
                tab.setAttribute('aria-selected', isActive ? 'true' : 'false');
            });

            // Update notification count header
            if (filteredNotifications.length > 0) {
                elements.notificationCount.textContent = `${filteredNotifications.length} notifications`;
            } else {
                elements.notificationCount.textContent = '';
            }

            // Show/hide select all row
            const showSelectAll = filteredNotifications.length > 0;
            elements.selectAllRow.style.display = showSelectAll ? 'flex' : 'none';

            // Update select all checkbox state
            if (showSelectAll) {
                const selectedInFilter = filteredNotifications.filter(n => state.selected.has(n.id)).length;
                const allSelected = selectedInFilter === filteredNotifications.length;
                const someSelected = selectedInFilter > 0 && !allSelected;

                elements.selectAllCheckbox.checked = allSelected;
                elements.selectAllCheckbox.indeterminate = someSelected;

                // Update selection count
                if (state.selected.size > 0) {
                    elements.selectionCount.textContent = `${state.selected.size} selected`;
                    elements.selectionCount.className = 'selection-count has-selection';
                } else {
                    elements.selectionCount.textContent = '';
                    elements.selectionCount.className = 'selection-count';
                }

                // Show/hide Mark Done button
                elements.markDoneBtn.style.display = state.selected.size > 0 ? 'inline-block' : 'none';
            }

            // Update progress bar
            if (state.markingInProgress) {
                elements.progressContainer.className = 'progress-container visible';
                const percent = (state.markProgress.current / state.markProgress.total) * 100;
                elements.progressBarFill.style.width = `${percent}%`;
                elements.progressText.textContent = `Marking ${state.markProgress.current} of ${state.markProgress.total}...`;
            } else {
                elements.progressContainer.className = 'progress-container';
            }

            // Render notifications list
            elements.notificationsList.innerHTML = '';

            if (filteredNotifications.length > 0) {
                filteredNotifications.forEach(notif => {
                    const li = document.createElement('li');
                    const isSelected = state.selected.has(notif.id);
                    li.className = 'notification-item' +
                        (notif.unread ? ' unread' : '') +
                        (isSelected ? ' selected' : '');
                    li.setAttribute('data-id', notif.id);
                    li.setAttribute('data-type', notif.subject.type);
                    li.setAttribute('data-state', notif.subject.state || '');

                    // Build notification HTML
                    const iconClass = getIconStateClass(notif);
                    const iconSvg = getNotificationIcon(notif);
                    const stateBadge = getStateBadge(notif);
                    const relativeTime = formatRelativeTime(notif.updated_at);
                    const reason = formatReason(notif.reason);
                    const commentStatus =
                        state.commentPrefetchEnabled || state.filter === 'uninteresting'
                            ? getCommentStatus(notif)
                            : null;
                    const commentBadge = commentStatus
                        ? `<span class="comment-tag ${commentStatus.className}">${escapeHtml(commentStatus.label)}</span>`
                        : '';
                    const commentItems = getCommentItems(notif);
                    const commentList = commentItems
                        ? `<ul class="comment-list">${commentItems}</ul>`
                        : '';
                    const doneButton = `
                        <button
                            type="button"
                            class="notification-done-btn"
                            aria-label="Mark notification as done"
                            ${state.markingInProgress ? 'disabled' : ''}
                        >
                            ${icons.check}
                        </button>
                    `;

                    // Actors HTML
                    let actorsHtml = '';
                    if (notif.actors && notif.actors.length > 0) {
                        actorsHtml = '<div class="notification-actors">';
                        notif.actors.slice(0, 3).forEach(actor => {
                            actorsHtml += `<img class="actor-avatar" src="${actor.avatar_url}" alt="${actor.login}" title="${actor.login}">`;
                        });
                        actorsHtml += '</div>';
                    }

                    li.innerHTML = `
                        <input
                            type="checkbox"
                            class="notification-checkbox"
                            ${isSelected ? 'checked' : ''}
                            ${state.markingInProgress ? 'disabled' : ''}
                            aria-label="Select notification: ${escapeHtml(notif.subject.title)}"
                        >
                        <div class="notification-icon ${iconClass}" data-type="${notif.subject.type}">
                            ${iconSvg}
                        </div>
                        <div class="notification-content">
                            <a href="${notif.subject.url}" class="notification-title" target="_blank" rel="noopener">
                                ${escapeHtml(notif.subject.title)}
                            </a>
                            <div class="notification-meta">
                                ${notif.subject.number ? `<span class="notification-number">#${notif.subject.number}</span>` : ''}
                                ${stateBadge}
                                <span class="notification-reason">${reason}</span>
                                ${commentBadge}
                            </div>
                            ${commentList}
                        </div>
                        ${actorsHtml}
                        <div class="notification-actions-inline">
                            <time class="notification-time" datetime="${notif.updated_at}" title="${new Date(notif.updated_at).toLocaleString()}">
                                ${relativeTime}
                            </time>
                            ${doneButton}
                        </div>
                    `;

                    // Add checkbox click handler
                    const checkbox = li.querySelector('.notification-checkbox');
                    checkbox.addEventListener('click', (e) => {
                        e.stopPropagation();
                        handleNotificationCheckbox(notif.id, e);
                    });

                    const doneBtn = li.querySelector('.notification-done-btn');
                    doneBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        handleInlineMarkDone(notif.id, doneBtn);
                    });

                    elements.notificationsList.appendChild(li);
                });
            }
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function parseRepoInput(value) {
            const trimmed = value.trim();
            if (!trimmed) {
                return null;
            }
            const parts = trimmed.split('/');
            if (parts.length !== 2 || !parts[0] || !parts[1]) {
                return null;
            }
            return { owner: parts[0], repo: parts[1] };
        }

        // Start the app
        init();
    </script>
</body>
</html>
